name: Deploy Infra & Configure Server

on:
  push:
    branches:
      - main
      - last-deploy
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Checkout
      - name: Checkout repository
        uses: actions/checkout@v3

      # Install Terraform
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_wrapper: false

      # Add AWS credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}


      # Terraform INIT
      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      # Terraform PLAN
      - name: Terraform Plan
        working-directory: terraform
        run: terraform plan

      # Terraform APPLY
      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply  -auto-approve


      - name: Get Connection Info
        working-directory: terraform
        run: |
          # Terraform output is a list of IPs. We extract the first IP 
          # for use in single-host SSH/Rsync commands. This IP is now your stable EIP.
          EC2_IP_LIST=$(terraform output -raw instance_public_ip)
          FIRST_EC2_IP=$(echo $EC2_IP_LIST | awk '{print $1}')
          
          echo "EC2_IP=$FIRST_EC2_IP" >> $GITHUB_ENV
          echo "KEY_FILE=$(terraform output -raw ssh_private_key)" >> $GITHUB_ENV
          
          echo "First EC2 IP set to: $FIRST_EC2_IP"

      - name: Install Dependencies (Ansible and Netcat)
        run: |
          echo "EC2_IP is ${{ env.EC2_IP }}"
          echo "Private key file is ${{ env.KEY_FILE }}"
          sudo apt-get update -y
          # Install Ansible and netcat-openbsd (for 'nc -z')
          sudo apt-get install -y ansible netcat-openbsd


      - name: Wait for SSH Port (22) to be ready on EC2
        run: |
          TARGET_IP="${{ env.EC2_IP }}"
          MAX_RETRIES=15
          SLEEP_SECONDS=10
          RETRY_COUNT=0
          
          echo "Waiting for SSH (Port 22) on $TARGET_IP to become available..."
          
          # 'nc -z' checks if the port is open; we retry up to MAX_RETRIES times
          until nc -z -w 5 $TARGET_IP 22; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -gt $MAX_RETRIES ]; then
              echo "Error: Timeout waiting for SSH on $TARGET_IP after $RETRY_COUNT retries."
              exit 1
            fi
            echo "SSH not ready yet. Retrying in $SLEEP_SECONDS seconds... (Attempt $RETRY_COUNT/$MAX_RETRIES)"
            sleep $SLEEP_SECONDS
          done
          
          echo "SSH port on $TARGET_IP is open! Continuing deployment."
        shell: bash

      # Run Ansible playbook
      - name: Run Ansible provision
        working-directory: terraform
        env:
          ANSIBLE_HOST_KEY_CHECKING: "False"
        run: |
          echo "--- Generated hosts.ini for Ansible ---"
          cat hosts.ini
          echo "-------------------------------------"
          # FIXED PATH: The inventory file is in the current working directory (terraform)
          ansible-playbook -i hosts.ini ../ansible/playbook.yaml

      # Check User Groups
      - name: Check User Groups (Debug)
        working-directory: terraform
        run: |
          echo "Checking groups for user ubuntu on ${{ env.EC2_IP }}..."
          ssh -i ${{ env.KEY_FILE }} -o StrictHostKeyChecking=no ubuntu@${{ env.EC2_IP }} "groups"

      - name: Deploy Code via Rsync
        working-directory: terraform
        run: |
          # The wait step ensures SSH is ready before Rsync attempts connection
          rsync -avz -e "ssh -i ${{ env.KEY_FILE }} -o StrictHostKeyChecking=no" \
          --exclude '.git' \
          --exclude 'terraform' \
          --exclude 'ansible' \
          --exclude 'node_modules' \
          ../ ubuntu@${{ env.EC2_IP }}:/home/ubuntu/app/

      # Create .env file on EC2 instance from GitHub secrets
      - name: Create Backend Env File
        working-directory: terraform
        env:
          ENV_BACKEND_CONTENT: ${{ secrets.ENV_BACKEND_CONTENT }}
        run: |
          # The 'EOF' must be quoted ('EOF') to prevent shell variable expansion 
          # on the GitHub Actions runner (which would corrupt $ENV_BACKEND_CONTENT)
          ssh -i ${{ env.KEY_FILE }} -o StrictHostKeyChecking=no ubuntu@${{ env.EC2_IP }} << 'EOF'
            cd /home/ubuntu/app/backend/config
            
            # Create the .env file with the secret content
            echo "$ENV_BACKEND_CONTENT" > .env
            
            # Verify it was created
            echo ".env file created successfully"
            ls -la .env
          EOF

      # Start Docker Containers
      - name: Start Docker Containers
        working-directory: terraform
        run: |
          # Connect via SSH and run these commands on the server
          ssh -i ${{ env.KEY_FILE }} -o StrictHostKeyChecking=no ubuntu@${{ env.EC2_IP }} << 'EOF'
            cd /home/ubuntu/app
            
            # Stop old containers if running
            sudo docker compose down || true
            
            # Start new containers (rebuilding if necessary)
            sudo docker compose up -d --build
          EOF
